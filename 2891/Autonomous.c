#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     irSensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     sonarSensor,    sensorSONAR)
#pragma config(Motor,  motorB,          feedingMotorDos, tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     backRightMotor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     frontRightMotor,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorJ, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorK,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     motorL, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorM,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     frontLeftMotor, 			 tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     backLeftMotor,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
//#inlcude "TankArcadeDrive.c"
//#include "IRTest.c"
//different variables assigned as floats
float pie = 3.14159;
float track = 17.0;
float halfTrack = track / 2.0;
float wheelDiam = 3.88;
float wheelRadius = wheelDiam / 2.0;
float wheelCircumference = wheelDiam * PI;
float ticksPerInches = 2160 / wheelCircumference;
float ticksPerInchesNeveRest=1680/wheelCircumference;
float halfRobotCircumference = track*pie;
float robotCircumference = track*2*pie;
float j = 0;
//float feet = 168;
//float motorSpeed = 50;

void moveBackward(float feet, float motorSpeed)
{
	nMotorEncoder[backRightMotor] = 0;
	float inches= feet * 12;
	int nTicks= (0.83 * feet * 12.0) - 1.0;
	while(abs(nMotorEncoder[backRightMotor]) < nTicks)
	{
			motor[frontRightMotor] = motorSpeed;
			motor[frontLeftMotor] = motorSpeed;
			motor[backRightMotor] = -motorSpeed;
			motor[backLeftMotor] = motorSpeed;
	}
	motor[frontLeftMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[backRightMotor] = 0;
	motor[backLeftMotor] = 0;
}
void moveFoward(float feet, float motorSpeed)
{
	nMotorEncoder[backLeftMotor] = 0;
	float inches= (0.83 * feet * 12.0) - 1.0;
	inches-=4;
	float nTicks=inches*ticksPerInches;
	//nTicks -= nTicks * calcPercentErrorMoveForward(feet);
	//nTicks-=nTicks*0.295;
	//writeDebugStreamLc dine("ticks: %d", nTicks);
	while(abs(nMotorEncoder[backLeftMotor]) < nTicks)
	{

			motor[frontRightMotor] = -motorSpeed;
			motor[frontLeftMotor] = -motorSpeed;
			motor[backRightMotor] = motorSpeed;
			motor[backLeftMotor] = -motorSpeed;
			writeDebugStreamLine("ticks: %d", nMotorEncoder[backLeftMotor]);
	}

	motor[frontLeftMotor] = 0;
	motor[frontRightMotor] = 0;
	motor[backRightMotor] = 0;
	motor[backLeftMotor] = 0;

}

	void rightTwoWheelTurn(float degreesMoved, float motorSpeed)
	{
		nMotorEncoder[backLeftMotor] = 0;
		float nTicks = abs((degreesMoved*halfTrack)/(wheelRadius));
		//nticks= nticks* 1.3 * 5/ 9;
		while(abs(nMotorEncoder[backLeftMotor]) < nTicks*5)
	{
			motor[frontRightMotor] = motorSpeed;
			motor[frontLeftMotor] = -motorSpeed;
			motor[backRightMotor] = -motorSpeed;
			motor[backLeftMotor] = -motorSpeed;
	}
}
	void leftTwoWheelTurn(float degreesMoved, float motorSpeed)
	{
		nMotorEncoder[backLeftMotor] = 0;
		float nTicks = abs((degreesMoved*halfTrack)/(wheelRadius));
		//nticks= nticks* 1.3 * 5/ 9;
		while(abs(nMotorEncoder[backLeftMotor]) < nTicks*5)
	{
			motor[frontRightMotor] = -motorSpeed;
			motor[frontLeftMotor] = motorSpeed;
			motor[backRightMotor] = motorSpeed;
			motor[backLeftMotor] = motorSpeed;
	}
}
	void knockPole (int position){//position 1,2,or 3
			if(position==3){
				int nfeet=47.0/12.0;
				moveFoward(nfeet, 100);
			  wait1Msec(1.0);
			 	rightTwoWheelTurn(85, 100);
			 	wait1Msec(0.5);
			 	nfeet=20.0/12.0;
			 	moveFoward(nfeet, 100);
			 	wait1Msec(0.5);
			 	rightTwoWheelTurn(45.0,75.0);
			 	/*wait1Msec(0.5);
			 	moveForward(2.0/12.0, 100);
			  /*wait1Msec(.5);
				moveFoward(2, 75);
				wait1Msec(0.5);
				leftTwoWheelTurn(9.0, 75);
				wait1Msec(.5);
				moveFoward(.68, 125);
				wait1Msec(.5);
				leftTwoWheelTurn(58.0, 80);
				wait1Msec(.5);
				moveFoward(.9, 125);*/
			}else if(position ==2){
				moveFoward(22.0/12.0, 75);
				//moveFoward(0,0);
				wait1Msec(1);
				rightTwoWheelTurn(62.5, 85);
				wait1Msec(1);
				moveFoward(32.0/12.0, 150);
				wait1Msec(0.5);
				rightTwoWheelTurn(45.0, 75.0);
			}else if(position ==1 ){
				moveFoward(18.0/12.0, 75);
				wait1Msec(1);
			  rightTwoWheelTurn(90.0, 85);
			  wait1Msec(0.5);
				moveFoward(36.0/12.0, 50);
				wait1Msec(2.0);
				leftTwoWheelTurn(37.5, 75);
				wait1Msec(0.5);
				moveFoward(14.0/12.0, 50);
				wait1Msec(0.5);
				rightTwoWheelTurn(45.0, 50);
			}
	}



task main(){
	knockPole(1);

}
